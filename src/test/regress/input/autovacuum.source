create or replace function test_consume_xids(int4) returns void
as '@abs_srcdir@/regress.so', 'test_consume_xids'
language C;

set debug_burn_xids=on;

-- Speed up test.
ALTER SYSTEM SET autovacuum_naptime = 5;
select * from pg_reload_conf();

-- Vacuum database
vacuum;

-- Show autovacuum_max_workers
show autovacuum_max_workers;

-- Autovacuum should take care of anti-XID wraparounds of catalog tables.
-- Because of that, the age of pg_class should not go much above
-- autovacuum_freeze_max_age (we assume the default of 200 million here).
SELECT age(relfrozenxid) < 200 * 1000000 FROM pg_class WHERE relname='pg_class';

-- Suspend the autovacuum worker from vacuuming before
-- ShmemVariableCache->latestCompletedXid is expected to be updated
SELECT gp_inject_fault('auto_vac_worker_before_do_autovacuum', 'suspend', '', 'regression', '', 1, -1, 0, 1);

-- Suspend the autovacuum worker after vacuuming
SELECT gp_inject_fault('auto_vac_worker_after_do_autovacuum', 'suspend', '', 'regression', '', 1, -1, 0, 1);

select test_consume_xids(100 * 1000000);
select test_consume_xids(100 * 1000000);
select test_consume_xids(10 * 1000000);

SELECT age(relfrozenxid) < 200 * 1000000 FROM pg_class WHERE relname='pg_class';

-- Note that autovacuum laucher will continue start new worker for the same database
-- when the old worker is blocked. There are at most 3(autovacuum_max_workers) workers
-- Wait until the three autovacuum workers are triggered
SELECT gp_wait_until_triggered_fault('auto_vac_worker_before_do_autovacuum', 3, 1);
SELECT gp_inject_fault('auto_vac_worker_before_do_autovacuum', 'reset', 1);

-- wait until three autovacuum workers finish vacuum
SELECT gp_wait_until_triggered_fault('auto_vac_worker_after_do_autovacuum', 3, 1);
SELECT gp_inject_fault('auto_vac_worker_after_do_autovacuum', 'reset', 1);

-- catalog table should be young
SELECT age(relfrozenxid) < 200 * 1000000 FROM pg_class WHERE relname='pg_class';

-- Reset GUCs.
ALTER SYSTEM RESET autovacuum_naptime;
select * from pg_reload_conf();
